"use client"

import React, { useRef, useMemo, useState, useEffect, Suspense } from "react"
import { Canvas, useFrame } from "@react-three/fiber"
import { useTexture } from "@react-three/drei"
import * as THREE from "three"

type ImageItem = string | { src: string; alt?: string }

interface FadeSettings {
  fadeIn: { start: number; end: number }
  fadeOut: { start: number; end: number }
}

interface BlurSettings {
  blurIn: { start: number; end: number }
  blurOut: { start: number; end: number }
  maxBlur: number
}

interface InfiniteGalleryProps {
  images: ImageItem[]
  speed?: number
  zSpacing?: number
  visibleCount?: number
  falloff?: { near: number; far: number }
  fadeSettings?: FadeSettings
  blurSettings?: BlurSettings
  className?: string
  style?: React.CSSProperties
  scrollProgress?: number
}

interface PlaneData {
  index: number
  z: number
  imageIndex: number
  x: number
  y: number
}

const DEFAULT_DEPTH_RANGE = 50
const MAX_HORIZONTAL_OFFSET = 8
const MAX_VERTICAL_OFFSET = 8

const createClothMaterial = () =>
  new THREE.ShaderMaterial({
    transparent: true,
    uniforms: {
      map: { value: null },
      opacity: { value: 1.0 },
      blurAmount: { value: 0.0 },
      scrollForce: { value: 0.0 },
      time: { value: 0.0 },
      isHovered: { value: 0.0 },
    },
    vertexShader: `
      uniform float scrollForce;
      uniform float time;
      uniform float isHovered;
      varying vec2 vUv;
      void main() {
        vUv = uv;
        vec3 pos = position;
        float curveIntensity = scrollForce * 0.3;
        float distanceFromCenter = length(pos.xy);
        float curve = distanceFromCenter * distanceFromCenter * curveIntensity;
        float ripple1 = sin(pos.x * 2.0 + scrollForce * 3.0) * 0.02;
        float ripple2 = sin(pos.y * 2.5 + scrollForce * 2.0) * 0.015;
        float clothEffect = (ripple1 + ripple2) * abs(curveIntensity) * 2.0;
        float flagWave = 0.0;
        if (isHovered > 0.5) {
          float wavePhase = pos.x * 3.0 + time * 8.0;
          float waveAmplitude = sin(wavePhase) * 0.1;
          float dampening = smoothstep(-0.5, 0.5, pos.x);
          flagWave = waveAmplitude * dampening;
          float secondaryWave = sin(pos.x * 5.0 + time * 12.0) * 0.03 * dampening;
          flagWave += secondaryWave;
        }
        pos.z -= (curve + clothEffect + flagWave);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D map;
      uniform float opacity;
      uniform float blurAmount;
      uniform float scrollForce;
      varying vec2 vUv;
      void main() {
        vec4 color = texture2D(map, vUv);
        if (blurAmount > 0.0) {
          vec2 texelSize = 1.0 / vec2(textureSize(map, 0));
          vec4 blurred = vec4(0.0);
          float total = 0.0;
          for (float x = -2.0; x <= 2.0; x += 1.0) {
            for (float y = -2.0; y <= 2.0; y += 1.0) {
              vec2 offset = vec2(x, y) * texelSize * blurAmount;
              float weight = 1.0 / (1.0 + length(vec2(x, y)));
              blurred += texture2D(map, vUv + offset) * weight;
              total += weight;
            }
          }
          color = blurred / total;
        }
        float curveHighlight = abs(scrollForce) * 0.05;
        color.rgb += vec3(curveHighlight * 0.1);
        gl_FragColor = vec4(color.rgb, color.a * opacity);
      }
    `,
  })

function ImagePlane({
  texture,
  position,
  scale,
  material,
}: {
  texture: THREE.Texture
  position: [number, number, number]
  scale: [number, number, number]
  material: THREE.ShaderMaterial
}) {
  const meshRef = useRef<THREE.Mesh>(null)
  const [isHovered, setIsHovered] = useState(false)

  useEffect(() => {
    material.uniforms.map.value = texture
  }, [material, texture])

  useEffect(() => {
    material.uniforms.isHovered.value = isHovered ? 1 : 0
  }, [material, isHovered])

  return (
    <mesh
      ref={meshRef}
      position={position}
      scale={scale}
      material={material}
      onPointerEnter={() => setIsHovered(true)}
      onPointerLeave={() => setIsHovered(false)}
    >
      <planeGeometry args={[1, 1, 32, 32]} />
    </mesh>
  )
}

function GalleryScene({
  images,
  speed = 1,
  visibleCount = 8,
  fadeSettings = {
    fadeIn: { start: 0.05, end: 0.15 },
    fadeOut: { start: 0.85, end: 0.95 },
  },
  blurSettings = {
    blurIn: { start: 0.0, end: 0.1 },
    blurOut: { start: 0.9, end: 1.0 },
    maxBlur: 3.0,
  },
  scrollProgress,
}: Omit<InfiniteGalleryProps, "className" | "style">) {
  const scrollState = useRef({ position: 0 })
  const hasScrollControl = typeof scrollProgress === "number"

  const normalizedImages = useMemo(
    () => images.map((img) => (typeof img === "string" ? { src: img, alt: "" } : img)),
    [images]
  )

  const textures = useTexture(normalizedImages.map((img) => img.src))

  const materials = useMemo(
    () => Array.from({ length: visibleCount }, () => createClothMaterial()),
    [visibleCount]
  )

  const spatialPositions = useMemo(() => {
    const positions: { x: number; y: number }[] = []
    for (let i = 0; i < visibleCount; i++) {
      const horizontalAngle = (i * 2.618) % (Math.PI * 2)
      const verticalAngle = (i * 1.618 + Math.PI / 3) % (Math.PI * 2)
      const horizontalRadius = (i % 3) * 1.2
      const verticalRadius = ((i + 1) % 4) * 0.8
      const x = (Math.sin(horizontalAngle) * horizontalRadius * MAX_HORIZONTAL_OFFSET) / 3
      const y = (Math.cos(verticalAngle) * verticalRadius * MAX_VERTICAL_OFFSET) / 4
      positions.push({ x, y })
    }
    return positions
  }, [visibleCount])

  const totalImages = normalizedImages.length
  const depthRange = DEFAULT_DEPTH_RANGE

  const planesData = useRef<PlaneData[]>(
    Array.from({ length: visibleCount }, (_, i) => ({
      index: i,
      z: visibleCount > 0 ? ((depthRange / visibleCount) * i) % depthRange : 0,
      imageIndex: totalImages > 0 ? i % totalImages : 0,
      x: spatialPositions[i]?.x ?? 0,
      y: spatialPositions[i]?.y ?? 0,
    }))
  )

  useEffect(() => {
    planesData.current = Array.from({ length: visibleCount }, (_, i) => ({
      index: i,
      z:
        visibleCount > 0
          ? ((depthRange / Math.max(visibleCount, 1)) * i) % depthRange
          : 0,
      imageIndex: totalImages > 0 ? i % totalImages : 0,
      x: spatialPositions[i]?.x ?? 0,
      y: spatialPositions[i]?.y ?? 0,
    }))
  }, [depthRange, spatialPositions, totalImages, visibleCount])

  useFrame((state, delta) => {
    const time = state.clock.getElapsedTime()
    const previousPosition = scrollState.current.position
    const normalizedScroll = hasScrollControl
      ? THREE.MathUtils.clamp(scrollProgress ?? 0, 0, 1)
      : 0
    const autoAdvance = previousPosition + delta * speed * 5
    const targetPosition = hasScrollControl
      ? normalizedScroll * depthRange
      : autoAdvance
    const nextPosition = THREE.MathUtils.lerp(previousPosition, targetPosition, 0.2)
    const movement = nextPosition - previousPosition
    scrollState.current.position = nextPosition

    materials.forEach((material) => {
      material.uniforms.time.value = time
      material.uniforms.scrollForce.value = movement
    })

    const imageAdvance = totalImages > 0 ? (visibleCount % totalImages || totalImages) : 0
    const totalRange = depthRange

    planesData.current.forEach((plane, i) => {
      let newZ = plane.z + movement

      if (!hasScrollControl) {
        while (newZ >= totalRange) {
          newZ -= totalRange
          if (imageAdvance > 0 && totalImages > 0) {
            plane.imageIndex = (plane.imageIndex + imageAdvance) % totalImages
          }
        }

        while (newZ < 0) {
          newZ += totalRange
          if (imageAdvance > 0 && totalImages > 0) {
            const step = plane.imageIndex - imageAdvance
            plane.imageIndex = ((step % totalImages) + totalImages) % totalImages
          }
        }
      } else {
        newZ = THREE.MathUtils.clamp(newZ, 0, totalRange)
      }

      plane.z = newZ
      plane.x = spatialPositions[i]?.x ?? 0
      plane.y = spatialPositions[i]?.y ?? 0
      const normalizedPosition = plane.z / totalRange

      const fade = (() => {
        if (normalizedPosition < fadeSettings.fadeIn.start) return 0
        if (normalizedPosition <= fadeSettings.fadeIn.end) {
          return (
            (normalizedPosition - fadeSettings.fadeIn.start) /
            (fadeSettings.fadeIn.end - fadeSettings.fadeIn.start)
          )
        }
        if (normalizedPosition >= fadeSettings.fadeOut.end) return 0
        if (normalizedPosition >= fadeSettings.fadeOut.start) {
          return (
            1 -
            (normalizedPosition - fadeSettings.fadeOut.start) /
              (fadeSettings.fadeOut.end - fadeSettings.fadeOut.start)
          )
        }
        return 1
      })()

      const blur = (() => {
        if (normalizedPosition < blurSettings.blurIn.start) return blurSettings.maxBlur
        if (normalizedPosition <= blurSettings.blurIn.end) {
          const progress =
            (normalizedPosition - blurSettings.blurIn.start) /
            (blurSettings.blurIn.end - blurSettings.blurIn.start)
          return blurSettings.maxBlur * (1 - progress)
        }
        if (normalizedPosition >= blurSettings.blurOut.end) return blurSettings.maxBlur
        if (normalizedPosition >= blurSettings.blurOut.start) {
          const progress =
            (normalizedPosition - blurSettings.blurOut.start) /
            (blurSettings.blurOut.end - blurSettings.blurOut.start)
          return blurSettings.maxBlur * progress
        }
        return 0
      })()

      const material = materials[i]
      material.uniforms.opacity.value = fade
      material.uniforms.blurAmount.value = blur
    })
  })

  if (normalizedImages.length === 0) return null

  return (
    <>
      {planesData.current.map((plane, i) => {
        const texture = textures[plane.imageIndex]
        const material = materials[i]
        if (!texture || !material) return null
        const worldZ = plane.z - depthRange / 2
        const width = (texture.image as HTMLImageElement)?.width ?? 1
        const height = (texture.image as HTMLImageElement)?.height ?? 1
        const aspect = width / height
        const scale: [number, number, number] =
          aspect > 1 ? [2 * aspect, 2, 1] : [2, 2 / aspect, 1]

        return (
          <ImagePlane
            key={plane.index}
            texture={texture}
            position={[plane.x, plane.y, worldZ]}
            scale={scale}
            material={material}
          />
        )
      })}
    </>
  )
}

function FallbackGallery({ images }: { images: ImageItem[] }) {
  const normalizedImages = useMemo(
    () => images.map((img) => (typeof img === "string" ? { src: img, alt: "" } : img)),
    [images]
  )

  return (
    <div className="flex h-full w-full flex-col items-center justify-center rounded-[30px] bg-white/60 p-4 text-slate-600">
      <p className="mb-4 font-semibold">WebGL not supported. Showing image list:</p>
      <div className="grid max-h-96 w-full grid-cols-2 gap-4 overflow-y-auto md:grid-cols-3">
        {normalizedImages.map((img, i) => (
          <img
            key={`${img.src}-${i}`}
            src={img.src}
            alt={img.alt ?? "gallery"}
            className="h-32 w-full rounded-xl object-cover"
          />
        ))}
      </div>
    </div>
  )
}

export default function InfiniteGallery({
  images,
  className = "h-[420px] w-full",
  style,
  fadeSettings,
  blurSettings,
  speed = 1,
  visibleCount = 8,
  scrollProgress,
}: InfiniteGalleryProps) {
  const [webglSupported, setWebglSupported] = useState(true)

  useEffect(() => {
    try {
      const canvas = document.createElement("canvas")
      const gl =
        canvas.getContext("webgl", { antialias: true }) ||
        canvas.getContext("experimental-webgl")
      if (!gl) setWebglSupported(false)
    } catch {
      setWebglSupported(false)
    }
  }, [])

  if (!webglSupported) {
    return (
      <div className={className} style={style}>
        <FallbackGallery images={images} />
      </div>
    )
  }

  return (
    <div className={className} style={style}>
      <Suspense fallback={<FallbackGallery images={images} />}>
        <Canvas camera={{ position: [0, 0, 0], fov: 55 }} gl={{ antialias: true, alpha: true }}>
          <GalleryScene
            images={images}
            speed={speed}
            visibleCount={visibleCount}
            fadeSettings={fadeSettings}
            blurSettings={blurSettings}
            scrollProgress={scrollProgress}
          />
        </Canvas>
      </Suspense>
    </div>
  )
}


